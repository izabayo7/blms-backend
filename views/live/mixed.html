<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>WebRTC Scalable Broadcast using RTCMultiConnection</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <style>
        video {
            height: 320px;
        }
    </style>
</head>

<body>
    <h1>
        WebRTC Scalable Broadcast using RTCMultiConnection
        <p class="no-mobile">
            Use peer-to-peer protocol to broadcast your video over 20+ users.
        </p>
    </h1>

    <section class="make-center">
        <p style="margin: 0; padding: 0; padding-bottom: 20px;">
            <div class="make-center">
                <input type="text" id="broadcast-id" value="room-xyz" autocorrect=off autocapitalize=off size=20>
                <button id="open-or-join">Open or Join Broadcast</button>
                <button id='btn-get-mixed-stream'>share screen</button>
                <button id='btn-remove-mixed-stream'>remove screen</button>
                <button id='btn-get-video-stream'>add video</button>
                <button id='btn-remove-video-stream'>remove video</button>
                <button id='btn-get-audio-stream'>add sound</button>
                <button id='btn-remove-audio-stream'>remove sound</button>
                <div class="make-center" id="broadcast-viewers-counter"></div>
        </p>

        <video id="video-preview" controls loop></video>
    </section>
    <script src="js/MultiStreamsMixer.min.js"></script>
    <script src="js/RTCMultiConnection.js"></script>
    <script src="../../node_modules/webrtc-adapter/out/adapter.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <!-- <script src="https://www.webrtc-experiment.com/RecordRTC.js"></script> -->
    <script>
        var connection = new RTCMultiConnection();
        /**
         * codes for multi stream mixer
         */

        let mixedStream
        var localStream

        var mixer;
        var videoPreview = document.querySelector('video');
        document.querySelector('#btn-get-mixed-stream').onclick = function () {

            // if (mixerOptions.value === 'camera-screen') {
            // updateMediaHTML('Capturing screen');
            getMixedCameraAndScreen();
            // }
        }

        document.querySelector('#btn-get-video-stream').onclick = function () {
            // connection.addStream('video');
            localStream = connection.streamEvents.selectFirst({
                local: true
            }).stream
            localStream.unmute('video');
        }

        document.querySelector('#btn-get-audio-stream').onclick = function () {
            // connection.addStream('audio');
            localStream = connection.streamEvents.selectFirst({
                local: true
            }).stream
            localStream.unmute();
        }

        // remove screen 
        document.querySelector('#btn-remove-mixed-stream').onclick = function () {

            // connection.removeStream(mixedStream.id);
            localStream = connection.streamEvents.selectFirst({
                local: true
            }).stream
            localStream.mute('screen');
        }

        // remove video 
        document.querySelector('#btn-remove-video-stream').onclick = function () {

            // connection.removeStream('video');
            localStream = connection.streamEvents.selectFirst({
                local: true
            }).stream
            localStream.mute('video');
        }

        // remove video 
        document.querySelector('#btn-remove-audio-stream').onclick = function () {

            // connection.removeStream('audio');
            localStream = connection.streamEvents.selectFirst({
                local: true
            }).stream
            localStream.mute('audio');
        }

        function getMixedCameraAndScreen() {
            if (navigator.getDisplayMedia) {
                navigator.getDisplayMedia({
                    video: true
                }).then(screenStream => {
                    afterScreenCaptured(screenStream);
                });
            } else if (navigator.mediaDevices.getDisplayMedia) {
                navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                }).then(screenStream => {
                    afterScreenCaptured(screenStream);
                });
            } else {
                alert('getDisplayMedia API is not supported by this browser.');
            }
        }

        function afterScreenCaptured(screenStream) {
            navigator.mediaDevices.getUserMedia({
                video: true
            }).then(function (cameraStream) {
                screenStream.fullcanvas = true;
                screenStream.width = screen.width; // or 3840
                screenStream.height = screen.height; // or 2160 

                cameraStream.width = parseInt((30 / 100) * screenStream.width);
                cameraStream.height = parseInt((30 / 100) * screenStream.height);
                cameraStream.top = screenStream.height - cameraStream.height;
                cameraStream.left = screenStream.width - cameraStream.width;

                fullCanvasRenderHandler(screenStream, 'Your Screen!');
                normalVideoRenderHandler(cameraStream, 'Your Camera!');

                mixer = new MultiStreamsMixer([screenStream, cameraStream]);

                mixer.frameInterval = 1;
                mixer.startDrawingFrames();

                // videoPreview.srcObject = mixer.getMixedStream();
                // videoPreview.id = event.stream.id;
                // videoPreview.play()

                addStreamStopListener(screenStream, function () {
                    mixer.releaseStreams();
                    videoPreview.pause();
                    videoPreview.srcObject = cameraStream;
                    videoPreview.play()

                    // cameraStream.getTracks().forEach(function (track) {
                    //     track.stop();
                    // });
                });
                mixedStream = mixer.getMixedStream()
                connection.addStream(mixedStream)
            });
        }

        function normalVideoRenderHandler(stream, textToDisplay, callback) {
            // on-video-render:
            // called as soon as this video stream is drawn (painted or recorded) on canvas2d surface
            stream.onRender = function (context, x, y, width, height, idx, ignoreCB) {
                if (!ignoreCB && callback) {
                    callback(context, x, y, width, height, idx, textToDisplay);
                    return;
                }

                context.font = '40px Georgia';
                var measuredTextWidth = parseInt(context.measureText(textToDisplay).width);
                x = x + (parseInt((width - measuredTextWidth)) / 2);
                y = (context.canvas.height - height) + 50;
                context.strokeStyle = 'rgb(255, 0, 0)';
                context.fillStyle = 'rgba(255, 255, 0, .5)';
                roundRect(context, x - 20, y - 35, measuredTextWidth + 40, 45, 20, true);
                var gradient = context.createLinearGradient(0, 0, width * 2, 0);
                gradient.addColorStop('0', 'magenta');
                gradient.addColorStop('0.5', 'blue');
                gradient.addColorStop('1.0', 'red');
                context.fillStyle = gradient;
                context.fillText(textToDisplay, x, y);
            };
        }


        function addStreamStopListener(stream, callback) {
            stream.addEventListener('ended', function () {
                callback();
                callback = function () {};
            }, false);
            stream.addEventListener('inactive', function () {
                callback();
                callback = function () {};
            }, false);
            stream.getTracks().forEach(function (track) {
                track.addEventListener('ended', function () {
                    callback();
                    callback = function () {};
                }, false);
                track.addEventListener('inactive', function () {
                    callback();
                    callback = function () {};
                }, false);
            });
        }


        function fullCanvasRenderHandler(stream, textToDisplay) {
            // on-video-render:
            // called as soon as this video stream is drawn (painted or recorded) on canvas2d surface
            stream.onRender = function (context, x, y, width, height, idx) {
                context.font = '50px Georgia';
                var measuredTextWidth = parseInt(context.measureText(textToDisplay).width);
                x = x + (parseInt((width - measuredTextWidth)) - 40);
                y = y + 80;
                context.strokeStyle = 'rgb(255, 0, 0)';
                context.fillStyle = 'rgba(255, 255, 0, .5)';
                roundRect(context, x - 20, y - 55, measuredTextWidth + 40, 75, 20, true);
                var gradient = context.createLinearGradient(0, 0, width * 2, 0);
                gradient.addColorStop('0', 'magenta');
                gradient.addColorStop('0.5', 'blue');
                gradient.addColorStop('1.0', 'red');
                context.fillStyle = gradient;
                context.fillText(textToDisplay, x, y);
            };
        }


        /**
         * Draws a rounded rectangle using the current state of the canvas.
         * If you omit the last three params, it will draw a rectangle
         * outline with a 5 pixel border radius
         * @param {CanvasRenderingContext2D} ctx
         * @param {Number} x The top left x coordinate
         * @param {Number} y The top left y coordinate
         * @param {Number} width The width of the rectangle
         * @param {Number} height The height of the rectangle
         * @param {Number} [radius = 5] The corner radius; It can also be an object 
         *                 to specify different radii for corners
         * @param {Number} [radius.tl = 0] Top left
         * @param {Number} [radius.tr = 0] Top right
         * @param {Number} [radius.br = 0] Bottom right
         * @param {Number} [radius.bl = 0] Bottom left
         * @param {Boolean} [fill = false] Whether to fill the rectangle.
         * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
         */
        // via: http://stackoverflow.com/a/3368118/552182
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke == 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {
                    tl: radius,
                    tr: radius,
                    br: radius,
                    bl: radius
                };
            } else {
                var defaultRadius = {
                    tl: 0,
                    tr: 0,
                    br: 0,
                    bl: 0
                };
                for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                }
            }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }

        /*******************************************************************/

        // recording is disabled because it is resulting for browser-crash
        // if you enable below line, please also uncomment above "RecordRTC.js"
        var enableRecordings = false;



        // https://www.rtcmulticonnection.org/docs/iceServers/
        // use your own TURN-server here!
        connection.iceServers = [{
            'urls': [
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302',
                'stun:stun.l.google.com:19302?transport=udp',
            ]
        }];

        // its mandatory in v3
        connection.enableScalableBroadcast = true;

        // each relaying-user should serve only 1 users
        connection.maxRelayLimitPerUser = 1;

        // we don't need to keep room-opened
        // scalable-broadcast.js will handle stuff itself.
        connection.autoCloseEntireSession = true;

        // by default, socket.io server is assumed to be deployed on your own URL
        connection.socketURL = '/';


        connection.socketMessageEvent = 'scalable-media-broadcast-demo';

        // document.getElementById('broadcast-id').value = connection.userid;

        // user need to connect server, so that others can reach him.
        connection.connectSocket(function (socket) {
            socket.on('logs', function (log) {
                document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___')
                    .replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
            });

            // this event is emitted when a broadcast is already created.
            socket.on('join-broadcaster', function (hintsToJoinBroadcast) {
                console.log('join-broadcaster', hintsToJoinBroadcast);

                connection.session = hintsToJoinBroadcast.typeOfStreams;
                connection.sdpConstraints.mandatory = {
                    OfferToReceiveVideo: !!connection.session.video,
                    OfferToReceiveAudio: !!connection.session.audio
                };
                connection.broadcastId = hintsToJoinBroadcast.broadcastId;
                connection.join(hintsToJoinBroadcast.userid);
            });

            socket.on('rejoin-broadcast', function (broadcastId) {
                console.log('rejoin-broadcast', broadcastId);

                connection.attachStreams = [];
                socket.emit('check-broadcast-presence', broadcastId, function (isBroadcastExists) {
                    if (!isBroadcastExists) {
                        // the first person (i.e. real-broadcaster) MUST set his user-id
                        connection.userid = broadcastId;
                    }

                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                });
            });

            socket.on('broadcast-stopped', function (broadcastId) {
                // alert('Broadcast has been stopped.');
                // location.reload();
                console.error('broadcast-stopped', broadcastId);
                alert('This broadcast has been stopped.');
            });

            // this event is emitted when a broadcast is absent.
            socket.on('start-broadcasting', function (typeOfStreams) {
                console.log('start-broadcasting', typeOfStreams);

                // host i.e. sender should always use this!
                connection.sdpConstraints.mandatory = {
                    OfferToReceiveVideo: false,
                    OfferToReceiveAudio: false
                };
                connection.session = typeOfStreams;

                // "open" method here will capture media-stream
                // we can skip this function always; it is totally optional here.
                // we can use "connection.getUserMediaHandler" instead
                connection.open(connection.userid)
            });
        });

        window.onbeforeunload = function () {
            // Firefox is ugly.
            document.getElementById('open-or-join').disabled = false;
        };

        var videoPreview = document.getElementById('video-preview');

        connection.onstream = function (event) {
            console.log('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
            // if (connection.isInitiator && event.type !== 'local') {
            //     return;
            // }

            connection.isUpperUserLeft = false;
            videoPreview.srcObject = event.stream;
            videoPreview.play();

            videoPreview.userid = event.userid;

            if (event.type === 'local') {
                videoPreview.muted = true;
            }

            if (connection.isInitiator == false && event.type === 'remote') {
                // he is merely relaying the media
                connection.dontCaptureUserMedia = true;
                connection.attachStreams = [event.stream];
                connection.sdpConstraints.mandatory = {
                    OfferToReceiveAudio: false,
                    OfferToReceiveVideo: false
                };

                connection.getSocket(function (socket) {
                    socket.emit('can-relay-broadcast');

                    if (connection.DetectRTC.browser.name === 'Chrome') {
                        connection.getAllParticipants().forEach(function (p) {
                            if (p + '' != event.userid + '') {
                                var peer = connection.peers[p].peer;
                                peer.getLocalStreams().forEach(function (localStream) {
                                    peer.removeStream(localStream);
                                });
                                event.stream.getTracks().forEach(function (track) {
                                    peer.addTrack(track, event.stream);
                                });
                                connection.dontAttachStream = true;
                                connection.renegotiate(p);
                                connection.dontAttachStream = false;
                            }
                        });
                    }

                    if (connection.DetectRTC.browser.name === 'Firefox') {
                        // Firefox is NOT supporting removeStream method
                        // that's why using alternative hack.
                        // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                        // need to ask all deeper nodes to rejoin
                        connection.getAllParticipants().forEach(function (p) {
                            if (p + '' != event.userid + '') {
                                connection.replaceTrack(event.stream, p);
                            }
                        });
                    }

                    // Firefox seems UN_ABLE to record remote MediaStream
                    // WebAudio solution merely records audio
                    // so recording is skipped for Firefox.
                    if (connection.DetectRTC.browser.name === 'Chrome') {
                        repeatedlyRecordStream(event.stream);
                    }
                });
            }

            // to keep room-id in cache
            localStorage.setItem(connection.socketMessageEvent, connection.sessionid);
        };

        // ask node.js server to look for a broadcast
        // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
        // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
        document.getElementById('open-or-join').onclick = function () {
            var broadcastId = document.getElementById('broadcast-id').value;
            if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
                alert('Please enter broadcast-id');
                document.getElementById('broadcast-id').focus();
                return;
            }

            document.getElementById('open-or-join').disabled = true;

            connection.extra.broadcastId = broadcastId;

            connection.session = {
                audio: true,
                video: true,
                oneway: true
            };

            connection.getSocket(function (socket) {
                socket.emit('check-broadcast-presence', broadcastId, function (isBroadcastExists) {
                    if (!isBroadcastExists) {
                        // the first person (i.e. real-broadcaster) MUST set his user-id
                        connection.userid = broadcastId;
                    }

                    console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                });
            });
        };

        connection.onstreamended = function (event) {
            var video = document.getElementById(event.streamid);
            if (video && video.parentNode) {
                video.parentNode.removeChild(video);
            }
        };

        connection.onleave = function (event) {
            if (event.userid !== videoPreview.userid) return;

            connection.getSocket(function (socket) {
                socket.emit('can-not-relay-broadcast');

                connection.isUpperUserLeft = true;

                if (allRecordedBlobs.length) {
                    // playing lats recorded blob
                    var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
                    videoPreview.src = URL.createObjectURL(lastBlob);
                    videoPreview.play();
                    allRecordedBlobs = [];
                } else if (connection.currentRecorder) {
                    var recorder = connection.currentRecorder;
                    connection.currentRecorder = null;
                    recorder.stopRecording(function () {
                        if (!connection.isUpperUserLeft) return;

                        videoPreview.src = URL.createObjectURL(recorder.getBlob());
                        videoPreview.play();
                    });
                }

                if (connection.currentRecorder) {
                    connection.currentRecorder.stopRecording();
                    connection.currentRecorder = null;
                }
            });
        };

        var allRecordedBlobs = [];

        function repeatedlyRecordStream(stream) {
            if (!enableRecordings) {
                return;
            }

            connection.currentRecorder = RecordRTC(stream, {
                type: 'video'
            });

            connection.currentRecorder.startRecording();

            setTimeout(function () {
                if (connection.isUpperUserLeft || !connection.currentRecorder) {
                    return;
                }

                connection.currentRecorder.stopRecording(function () {
                    allRecordedBlobs.push(connection.currentRecorder.getBlob());

                    if (connection.isUpperUserLeft) {
                        return;
                    }

                    connection.currentRecorder = null;
                    repeatedlyRecordStream(stream);
                });
            }, 30 * 1000); // 30-seconds
        };

        function disableInputButtons() {
            document.getElementById('open-or-join').disabled = true;
            document.getElementById('broadcast-id').disabled = true;
        }

        // ......................................................
        // ......................Handling broadcast-id................
        // ......................................................

        var broadcastId = '';
        if (localStorage.getItem(connection.socketMessageEvent)) {
            broadcastId = localStorage.getItem(connection.socketMessageEvent);
        } else {
            broadcastId = connection.token();
        }
        var txtBroadcastId = document.getElementById('broadcast-id');
        txtBroadcastId.value = broadcastId;
        txtBroadcastId.onkeyup = txtBroadcastId.oninput = txtBroadcastId.onpaste = function () {
            localStorage.setItem(connection.socketMessageEvent, this.value);
        };

        // below section detects how many users are viewing your broadcast

        connection.onNumberOfBroadcastViewersUpdated = function (event) {
            if (!connection.isInitiator) return;

            document.getElementById('broadcast-viewers-counter').innerHTML = 'Number of broadcast viewers: <b>' +
                event.numberOfBroadcastViewers + '</b>';
        };
    </script>

    <section class="no-mobile">
        <h2>How this works?</h2>
        <p>
            This module simply initializes socket.io and configures it in a way that single audio/video/screen stream
            can be shared/relayed over unlimited users without any <a
                href="https://www.webrtc-experiment.com/docs/RTP-usage.html">bandwidth/CPU usage issues</a>. Everything
            happens peer-to-peer!
        </p>
        <p>
            Check <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/2">this thread</a> or <a
                href="https://github.com/muaz-khan/WebRTC-Scalable-Broadcast">this github repository</a>.
        </p>
    </section>

    <footer>
        <small id="send-message"></small>
    </footer>

    <script src="https://www.webrtc-experiment.com/common.js"></script>
</body>

</html>